Day1
용어에 집중해서 공부! 80%만 감 잡아도 성공~!

운영체제 : 하드웨어를 관리하는 소프트웨어
                  컴퓨터 하드웨어/소프트웨어 전반적인 동작 이해.(특히 소프트웨어 관련 전반적인 동작 기술 이해) 
cf) 운영체제는 저장매체( SSD/HDD )에 설치됨. 컴퓨터를 키면 운영체제는 Memory에 올라간다(이건 모든 s/w가 그렇다.)

-대표적 운영체제  : UNIX, Windows OS, Mac OS
                                 ㄴ UNIX : 현대 운영체제 기술을 최초로 구현한 운영체제. 윈도우,맥os도 유닉스 기반으로 나왔다고 볼 수 있음.
                                 ㄴ LIinux : unix 계열 os 중 하나. 인터넷 서비스를 구동시키는 서버? 라는 환경에서 많이 쓰임.
- 운영체제의 역할
    1. 시스템 자원(System Resource = 하드웨어 ) 관리자.
              하드웨어 -> CPU, Memory(DRAM, RAM) , 입출력장치(마우스,모니터,네트웤) , 저장매체(SDD, HDD(하드디스크))
              하드웨어는 스스로 할 수 있는 것이 없다. 운영체제가 각 하드웨어를 얼마나 언제 어디에 사용할지 관리
    2. 사용자와 컴퓨터간의 커뮤니케이션 지원
    3. 컴퓨터 하드웨어와 응용 프로그램(엑셀, 카톡, 게임 등..)을 제어 (1과 비슷)


응용프로그램 : 운영체제를 제외한 나머지 소프트웨어
=Application(Pc에서) = App(폰에서)

- 운영체제는 응용프로그램을 관리 
    ㄴ 응용프로그램 실행, 응용 프로그램간의 권한 관리(ex>관리자 권한으로 실행) , 응용프로그램을 사용하는 사용자 관리(pc에 로그인등..) 

- 운영체제와 응용프로그램간의 관계
    ㄴ 응용프로그램 안에 무한반복문등이 있거나, 하드웨어 내의 모든 파일 삭제하거나 , CPU 독점하거나 하는 등을 막는다. -> os가 관리!

=>사용자가 사용하는 응용프로그램이 효율적으로,적절하게 동작하도록 지원.
     응용프로그램이 요청하는 시스템 리소스를 효율적으로 분배하고 지원하는S/W


- 응용 프로그램, 운영체제, 컴퓨터 하드웨어(시스템 리소스)관계
     응.프는 시민, OS는 도서관, 하드웨어는 책
     ->  시민은 도서관에 원하는 책(자원)을 요청-> 도서관은 적절한 책(자원)을 찾아서 시민에게 빌려줌 -> 시민이 기한 다되면 도서관이 자원회수
=> 운영체제는 응용프로그램이 요청하는 메모리를 허가,분배 / CPU 시간 제공 / IO devices 사용 허가,제어


*운영체제가 사용자를 위해 제공하는 인터페이스
쉘(Shell) : 사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 프로그램. 이것도 하나의 응용프로그램
                 쉘은 터미널 환경(CLI)과, GUI 환경 두 종류로 구분

*운영체제가 응용프로그램을 위해 제공하는 인터페이스
API(Application Programming Interface) : 함수로 제공. 요청서라고 볼 수 있다. 조건에 맞는 요청하기.
시스템콜 함수 호출하는걸 각 언어에 맞춰서 제공하는 것.
     ex) file open() 함수, printf() 
       ㄴ 함수의 종류가 너무 많아서 Library 형태로 묶어서 제공
시스템 콜 : 시스템 호출 인터페이스 . 운영체제가 운영체제 각 기능을 사용할 수 있도록 시스템 콜이라는 명령 또는 함수를 제공. 사용법이 복잡.

If 운영체제를 만들려면
운영체제 개발(kernel : 핵심 운영체제 기능을 가진 s/w) ->시스템콜 개발 -> API(library)개발 -> Shell프로그램 개발(안해도 괜춘) -> 응용프로그램 개발

cf) POSIX API : 유닉스 계열의 운영체제들은 대부분 이 시스템콜을 따른다.



Day2
CPU Protection Rings
cpu도 권한 모드를 갖고있다
- 사용자모드(user mode by appllication)  : cpu에 ring이 4개 있다면(ex>Intel CPU) 이건 Ring1 . 제일 바깥쪽. 일반적 명령 .
                                                                    사용자모드에서 특권명령 실행하려면 cpu가 실행 안함. 응용프로그램이 사용.
- 커널모드 (kerenel mode by OS) : Ring4. 특권 명령어 실행과 원하는 작업 수행을 위한 자원 접근을 가능케하는 모드 . 핵심소프트웨어를 지칭.
                                                        os가 cpu를 쓸 때 사용하는 모드라고 보면됨.
- 통상적으로 Level(Ring) 3 을 사용자 모드, Level(Ring) 0을 커널 모드로 사용
cf) kernel은 알맹이 , shell은 껍데기 -> shell은 kernel을 둘러싸고 있는 껍데기.
cf) Ring이 4개 있다면 나머지 Level1, 2 는 OS서비스

 시스템 콜은 커널모드로 실행!
- 커널모드에서만 실행 가능한 기능들이 있다.
- 커널모드로 실행하려면, 반드시 시스템콜을 사용해야함(거쳐야 함)
- 시스템콜은 OS에서 제공
- 응용프로그램->API->시스템콜 여기서 시스템콜 다음은 kernel영역으로 볼 수 있다.
- 시스템콜을 통과한 이후로는 진짜 실행되는 명령은 OS라는 특권을 갖고 CPU에서 커널모드에서 실행. 

우리가 실행하는 응용프로그램은 그 명령에 따라서 어떤명령은 사용자영역에서 실행되고, 어떤 명령은 시스템콜을 통해 커널모드에서 실행된다.

ex> 등본을 뗄 때는 특별한 신청서(시스템콜)를 쓰면, 동사무소 직원들이 특별한 권한을 갖고, 등본 출력 명령을 실행(kernel모드)

cf) 응용프로그래머 - 사용자 프로그램 개발. API갖고
     시스템프로그래머 - 운영체제 및 시스템 프로그램 (shell, api, system call) ,하드웨어 다룬다.

ex> 변수선언하고 파일 open하고 그파일 열렸는지 확인하는 코드에서
-> 첨부터 파일 open하기 전까진 사용자모드 , open하는 시스템콜을 호출했을때 커널모드로 전환. (파일은 저장매체에 있다. 시스템콜 호출해서 os안으로 들어가서 os에서 디스크영역을 조작하는 명령을 커널모드에서 수행 후 전달. ) 결과를 전달했을때 다시 사용자 모드로 전환된다.


●프로세스 스케쥴링 - 배치처리시스템, 시분할시스템, 멀티태스킹
배치처리시스템  = 일괄처리, 배치처리 , batch processing
- 컴퓨터 프로그램 실행 요청 순서에 따라 순차적으로 프로그램을 실행하는 방식. 한번에 등록된 여러 프로그램을 자동으로 이어지게 순차적으로 실행 가능
- 큐랑 비슷? FIFO . 왜냐면 application이 등록된 순서대로 실행하고 없어지니깐.
But. 앞의 프로그램이 실행 시간이 너무 많이 걸려도 그 다음 프로그램은 계속 기다려야함.  / 노래들으면서 문서작성 불가 / 여러 사용자가 동시에 하나의 컴퓨터 사용 못함.(동시에 하나의 컴퓨터 쓰면 컴퓨터 응답시간이 많이 걸린다. )
=> 그래서 멀티프로그래밍/ 시분할 시스템이 나옴.

시분할 시스템
다중 사용자 지원을 위해 컴퓨터 응답시간을 최소화 하는 시스템. 

멀티태스킹 (= 시분할시스템?)
단일 CPU에서 , 여러 응용프로그램이 동시에 실행되는 것 처럼 보이도록 하는 시스템.
mp3에 해당하는 음악을 미리 만들어놓고 사이사이에 문서 작성되도록. 사람이 인지하지 못할 정도로 짧은 시간으로 . 동시인거 처럼!

멀티프로세싱 : 여러 CPU에 하나의 프로그램을 병렬로 실행해서 실행속도를 극대화시키는 시스템.

멀티프로그래밍 
- 최대한 CPU를 많이 활용하도록 하는 시스템. 시간대비 CPU 활용도 높이자. 응용프로그램을 짧은 시간안에 실행완료 시키기
- 응용프로그램은 온전히 CPU를 쓰기 보다, 다른 작업을 중간에 필요로 하는 경우가 많다. 파일을 읽거나 프린팅을 할때는 저장매체를 가야하는데 둘다 시간이 오래 걸림. 이때 계속 기다리지 말고 다른 작업을 중간 중간에 처리.

만약에 ppt안의 코드 같이 실행할때 쭉 cpu가 순차적으로 실행하다가 파일을 open하라는 시스템 콜을 호출되었을때!
파일 열수있는지 확인하는건 일반 cpu속도보다 훨 느리다.(저장매체에서 처리속도느림) 그때 진행되던 cpu는 결과가 나올때까지 기다리는데 그게 blocking 상태.
그때 지금 cpu를 실행할 수 있는 다른 응용프로그램이 cpu를 이용하고, 파일 다 읽었으면 그때 다시 cpu가 그 프로그램을 실행.
=>이렇게 하면 cpu 활용도가 올라간다. 혁신적인 기술! 멀티태스킹이라는 자체에 이런 멀티 프로그래밍 자체가 포함?

cf) cycle : cpu에서 하나의 명령을 처리하는 단위. ms,us보다 훨씬 작은 단위.
DMA : System Bus를 보면 cpu가 저장매체(SSD)등에 갔다가 메모리 가고 하는데 시간 오래 걸리니 CPU는 다른거 하고 있고 DMA가 그걸 대신 하고 완료되면 cpu한테 준다.

실제로 시분할시스템, 멀티프로그래밍, 멀티태스킹이 유사한 의미로 통용됨.
=>여러 응용프로그램 실행 가능토록함 / 동시에 /  CPU 쉬지않고 짧은시간안에 프로그램 실행완료 되도록 / 응답시간 짧게 해서 다중사용자 지원



Day3
프로세스
- 메모리에 올려져서, 실행중인 프로그램.  (작업, task, job이라는 용어랑 혼용 )
- 원래 모든 코드는 메모리에 일단 올려진 다음에 한 줄씩 cpu에 넣어져서 실행되는 형식이다.
- 응용프로그램은 여러 개의 프로세스로 이루어질 수 있다.
- 하나의 응용프로그램은 여러개의 프로세스(프로그램)가 상호작용을 하면서 실행될 수도 있음. (특히 UNIX 철학)
cf) IPC 기법 : 여러 프로그램을 만들어서, 서로 통신하면서 프로그램을 작성. 프로세스간 통신하는 기법.

스케쥴러가 프로세스 실행을 관리!

스케쥴링 알고리즘
스케쥴링 알고리즘은 어느 순서대로 프로세스를 실행시킬지에 대한 것.
예를 들어 시분할 시스템(프로세스 응답시간 짧게), 멀티프로그래밍(CPU활용도 최대로 높혀서 프로세스 빨리 실행) 과 같은 목표를 가지고!

1. FIFO 스케쥴러 = FCFS 스케쥴러 ( ≒Queue ) 
프로세스가 저장매체 읽던, 프린팅을 하는 작업 없이, 쭉 CPU를 첨부터 끝까지 사용. 가장 기본적 스케쥴러 ≒ 배치 처리 시스템. 

2. 최단 작업 우선 SJF(Shortest Job First) 스케쥴러
가장 프로세스 실행시간이 짧은 프로세스부터 먼저 실행 시키는 알고리즘.

3. 우선순위 기반 스케쥴러 (Priority-Based)
정적 우선순위 : 프로세스마다 우선순위를 미리 지정
동적 우선순위 : 스케쥴러가 상황에 따라 우선순위를 동적으로 변경


4. Round Robin 스케쥴러
시분할 시스템 기반으로 각 단위 시간에 프로세스가 완료안되면 ready Queue의 맨 뒤로 다시 들어가서 진행


cf> RTOS (RealTime OS) : 응용프로그램 실시간 성능 보장을 목표로 하는 OS. 정확하게 프로그램 시작,완료 시간을 보장.
                                         시간에 민감한 프로세스인 경우ex)공장.  Hardware RTOS, Software RTOS
GPOS (General Purpose OS) : 프로세스 실행시간에 민감하지 않고, 일반적 목적 ex)Window, Linux,...


프로세스 상태
멀티프로그래밍(CPU활용도 극대화) 스케쥴링. 스케쥴러가 프로세스 상태정보를 필요로함
running state : 현재 CPU에서 실행상태
ready state : CPU에서 바로 실행 가능 상태(실행 대기 상태)
block state  :특정 이벤트 발생 대기 상태( 파일 읽기 다 끝내면 block -> ready) ≒ wait 상태
맨앞과 맨뒤에 new(생성중) , exit(종료를 위한 시간) 상태가 있긴하다.

state 별로 Queue를 둔다. 스케쥴러는 ready Queue에 있는 것들에서 하나 떼어서 받아서 실행한다.

                                     ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

idle 상태는 cpu가 아무것도 안하는 상태.


Day4
스케쥴링 알고리즘(policy)은 선점형 스케쥴러와 비선점형 스케쥴러로 나뉠 수 있다.

선점형 스케쥴러
- 스케쥴러가 지금 CPU에 있는 프로세스를 선점해서 제어를 하는 것.
- 하나의 프로세스가 다른 프로세스 대신에 프로세서(CPU)를 차지할 수 있음.
- 시분할 시스템 생각하면된다.  기본적으로 시분할 시스템은 선점형 스케쥴러가 지원이 되어야 함
- 구현이 어려워 비선점형보다 나중에 나옴.
- 프로세스 running 중에 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체 가능
- 요즘은 다 어떤 스케쥴러던 간에 선점형 이다.
- 응답시간 짧다.

비선점형 스케쥴러
- CPU에 있는 프로세서가 자체적으로 block되거나 실행이 끝났을때만(end되어야만) 그 때 다른 프로세스로 교체가능 하여 스케쥴러가 다른 프로세스 넣어줌.
- 스케쥴러가 제어x
- 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음.
- 응답시간 길다.


FIFO, SJF, Priority-based스케쥴러는 어떤 프로세스를 먼저 실행시킬 지에 대한 알고리즘 -> 비선점형에 가까움.
RoundRoboid 스케쥴러는 시분할 시스템을 위한 기본 알고리즘 -> 선점형 스케쥴러


cf> 만약 게임을 하거나 실행중인 프로세스가 많으면 마우스나 키보드,화면이 렉이 걸릴때가 있는데 이건 스케쥴러가 해결해야 하는 이슈다!
인터렉티브, IO, CPU중심 프로세스로 미리 구분할 수 있으면 개선된 스케쥴링 가능. type에 맞춰서!


인터럽트
- CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리하는 기술.
- CPU가 지금 실행하는 코드 외부에서 이벤트 발생했을 때 알려주는 기술. 어느 한순간 CPU가 실행하는 명령은 하나(코드1줄)에 집중하고 있다. 그때 알려주는것!
- 인터럽트는 운영체제 안에 개발되어있다.
- 선점형 스케쥴러 구현할 때 인터럽트는 반드시 필요!
  => 프로세스 running 중에 스케쥴러가 이를 중단시키고 , 다른 프로세스로 교체하기 위해 현재 프로세스 실행을 중단시킴
        그러려면 , 스케쥴러 코드가 실행이 되서, 현 프로세스 실행을 중지시켜야 한다.
- 저장매체에서 데이터 처리 완료시, 프로세스 깨워야 함 (block state -> ready state)   = 입출력 하드웨어 등의 장치이슈 발생
- 인터럽트는 일종의 이벤트. 이벤트에 맞게 OS가 처리.
- CPU는 PC(program counter)가 가르키고 있는 코드 한줄 한줄을 실행하는데 집중하고 있다. 그 때 외부에서 뭔가 이슈가 잇어서 그 이슈를 처리해야할 때, 그 정보를 어떻게 알려주고 그걸 누가 받아서 처리 하는지 그런게 다 OS안에서 처리된다.

주요 인터럽트
1. Divide-by-Zero Interrupt 
- 계산하는 코드에서 0으로나누는 코드 실행 시  인터럽트 발생.
- 코드상으로 보면 프로그램 kill되고 exception발생했다는 메세지가 나오는데 그게 이 인터럽트의 처리 루틴인 것.
2. 타이머 인터럽트
- 선점형 스케쥴러를 위해 필요
- 타이머 인터럽트를 발생시키는 장치가 컴퓨터 안에 별도의 칩으로 존재하고 일정기간마다 계속 발생시킴.
- 하드웨어로 부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려줌.
ex) 1/10초마다 프로세스 교체 하겠다 -> 타이머 인터럽트가 1/100초마다 발생할 때 10번했을 때 딱 스케쥴러가 깨서 돌면서 cpu에서 프로세스 교체 실행.
3. 입출력(IO) 인터럽트 
- 입출력 장비 별로 종류는 아주 다양.

인터럽트 종류
내부 인터럽트 : 주로 프로그램 내부에서 발생. = 소프트웨어 인터럽트
ex)리눅스에선 하나의 프로세스 공간을 기본적으로 4GB 갖고있다. 이 때 0~3GB는 사용자모드, 3~4GB는 커널모드. 사용자모드에서 프로세스가 실행되다가 씨언어 포인터가 잘못 쓰여져서 커널모드에 접근이 되면 바로 내부인터럽트 발생
외부인터럽트 : 주로 하드웨어에서 발생. = 하드웨어 인터럽트



Day5
시스템콜 인터럽트
시스템콜도 내부적으로 인터럽트 방식으로 처리한다.
시스템콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어, cpu에게 실행시켜야 한다.
mov eax, 1          : eax레지스터에 시스템 콜 번호 넣고
mov ebx, 0         : ebx레지스터에 시스템콜에 해당하는 인자값을 넣고,
int 0x80              :  소프트웨어 인터럽트 명령을 호출하면서 0x80값을 넘겨줌.
ㄴint는 그 숫자int아님. OPCODE임.
시스템 콜 인터럽트 명령을 호출하면서 0x80값을 넘겨주면
->CPU는 사용자모드를 커널모드로 바꿔줌
->IDT(Interrupt Descriptor Table) 에서 0x80에 해당하는 주소(함수)를 찾아서 실행함.
    ㄴ IDT 라는 테이블에 이벤트번호:실행코드주소(함수) 이런식으로 매핑되어있다.
-> system_call()함수에서 eax로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동
-> 해당 시스템콜함수 실행(in 커널영역) 후, 다시 커널 모드에서 사용자모드로 변경하고, 다시 해당 프로세스 다음 코드 진행

cf) 커널영역 : 커널모드에서 실행되는 코드들이 저장되어있는 영역
생각보다 프로세스는 사용자모드와 커널모드를 많이 왔다갔다 하면서 실행된다.
타이머 인터럽트도 커널모드이다. 

IDT 
- 인터럽트는 미리 정의되어 각각 번호와 실행 코드(운영체제 내부코드. 커널)를 가리키는 주소가 IDT에 기록되어있다.
- 컴퓨터 부팅 시 OS가 기록한다. 
- 항상 인터럽트 발생 시, IDT를 확인한다.
- 시스템 콜 인터럽트 명령은 0x80 번호. 0x80에 해당하는 운영체제 코드는 system_call()이라는 함수이다.
ex)In Linux -> 0~31 : 예외상황인터럽트(거의 내부인터럽트. ex)0 divide) / 32~47 : 하드웨어인터럽트 / 128 : 시스템콜 = 0x80


프로세스 구조와 컨텍스트 스위칭
컨텍스트 스위칭 : A라는 프로세스가 CPU에서 실행하다가 스케쥴러가 B라는 프로세스로 실행을 바꿔주는데 그때 바꿔주는 메커니즘

stack : 함수에 있는 변수와 같이 임시로 저장해야하는 것들 저장. 
heap : 동적으로 공간 필요한 것에 생기는거. 다른데 넣을데가 애매하니깐 heap을 만듦
data : 변수/초기화된 데이터
text(CODE) : 컴파일된 소스가 저장

cf)컴파일 : 컴퓨터가 이해하는 0과 1의 언어로 바뀌는것.


ㄴ 위 그림은 C언어 코드의 진행인데, c언어는 main함수가 먼저 실행되므로 stack에 main함수 변수들이 먼저 들어간다.
함수 meaningless를 호출 할 때 stack영역은 제일 위에서부터 return address(함수가 끝나고 그 다음에 가져갈 영역의 주소)와 순서대로 data,temp값이 저장.
함수가 끝나고 나선 temp값 없애고 data값없애고 return address없애면서 그 값음 PC(program counter)에 저장되고 해당하는 다음 코드 실행. 
또 main함수 끝나면 PC값을 그 return address값으로 변경하고 stack에서 없애기.


▼
- PC (Program Counter)  : 코드를 한줄 한줄 가르키는 주소 레지스터
- SP (Stack Pointer) :  함수가 실행될 때 그 stack frame의 가장 최상단 주소를 가르키는 레지스터
- stack은 위에서 아래로, heap은 아래서 위로 쌓인다.
- 위 그림에서 PC 초기값은 0000h , SP초기값은 1000h 이다.  EBP레지스터 초기값은 현재 stack프레임의 최상단 주소 1000h 이다.
- func(1,2) 함수가 실행되면 stack 프레임 맨 위에 EBP값인 1000h가 먼저 들어가고, 그 다음에 return address, a, b 값이 순서대로 들어간다.
(만약 func 함수안에 지역변수가 따로 있었으면 b 밑으로 지역변수가 써진다.). 그리고 SP값은 0ffch이 되고, EBP에도 SP값이 들어가고 b밑에 EBP값 들어간다.
- 함수 func의 리턴값은 EAX 레지스터 안에 들어간다.

EBP를 쓰는 이유 -> 코드가 막 함수안에 함수안에 함수.. 이렇게 실행시키다 문제 생기면 stack 전체에서 어떤 함수에서 시작되고 한지 알기가 어려움. 
EBP는 항상 각 함수의 최상단 stack pointer를 알게되니깐 알기 쉬워짐. 항상 stack에서 EBP밑에 return address가 있으니 그 return address 위의 줄이 그 문제의 함수라는게 알게되고 stack에선 그 밑의 지역값만 확인하면 뭐가 문젠지 알 수 있다.


-malloc() : 동적으로 메모리를 생성하는 함수. 인자는 size   <-> free() : 동적메모리 해제

int *data ;           ->포인터변수 설정
data = (int*)malloc(sizeof(int));          ->heap이라는 메모리공간에 32bit의 동적인 공간이 만들어지는 것. data는 이제 그 메모리 공간의 주소를 가르킨다.
*data = 1 ;                                          -> 가르키고 있는 주소로 찾아가서 그 메모리 공간에 1을 넣기.
ㄴ(여긴 EBP값 넣는건 일단 생략함.)
- stack에 생기는 int *data의 값은 heap의 주소. = 1000h


- 프로세스 구조에서 DATA영역은 BSS, DATA로 다시 분리됨
BSS : 초기화되지 않은 전역변수. int a;
DATA: 초기화 값이 있는 전역변수. int b=1;

cf) 전역변수는 main함수 전에 선언되어서 전역에 사용가능한거 <->지역변수

cf)스택오버프로우 : 프로세스구조를 활용한 해킹기법.
strcpy(data,bar)->bar에 있는걸 data에 복사(마지막 마무리 기호 있을 때까지) . 이 함수를 이용해서 복사를 할 때 char data[6]으로 선언 해놓고 복사하는 bar값은 사이즈가 8이면 stack에는 data[]에 해당하는 자리는 6개있는데 나머지 두개는 위에 있는거에 덮어쯰워져서 return addr까지 덮어씌워짐. 그럼 return addr 주소를 바꿀 수 있다.

PCB
Process Control(Context) Block  
- 스케쥴러가 processA에서 B 실행으로 바뀔때 A의 PC값과 SP값은 운영체제가 PCB라는 별도의 저장공간을 메모리에 만들어서 관리
  다시 B에서 A로 돌아올때는 B의 PC,SP값을 PCB에 저장하고 원래 저장했던 값은 현재 CPU의 PC와 SP레지스터안에 넣는다.
- 프로세스가 실행중인 상태를 OS단에서 캡처/구조화해서 저장
- processID , Resgister값(PC,SP,..) ,Scheduling Info(Process State. ready?block?) , Memory Info(메모리 사이즈 limit),우선순위정보 등 갖고있다.
- PC,SP저장해서 컨텍스트 스위칭 관여 & 스케쥴링 정보 저장해서 스케쥴링도 관여.

컨텍스트 스위칭( 문맥교환 )
- CPU 에 실행할 프로세스를 교체하는 기술.
- 컨텍스트 스위칭 관련 코드가 실행되면, 1.실행 중지할 프로세스 정보를 해당 프로세스의  PCB에 업데이트해서, 메인메모리에 저장 후 2.다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB정보를 CPU에 넣고, 3. 실행
cf) 디스패치(dispatch) : ready 상태의 프로세스를 running 상태로 바꾸는 것.

- 엄청 빈번하게 일어나기 때문에 실행속도가 늘어날 수 있다.  (1초에 100번 이상)
=> 컨텍스트 스위칭 시간을 짧게 하기 위해서 C언어가 아닌 어셈블리어로 작성. 
      운영체제는 어셈블리어로 작성되는 경우가 거의 없는데 컨텍스트 스위칭 코드만 어셈블리어로 작성됨(리눅스인 경우에!)
      리눅스의 경우 컨텍스트 스위칭 코드는 각 CPU마다 별도로 존재

cf) 어셈블리어(기계어)
- 초기 컴퓨터 프로그램들은 어셈블리어로 작성.
- 서로 다른 CPU아키텍처가 등장할 때 마다 매번 똑같은 프로그램 작성해야함....
- 어셈블리어로는 프로그램 작성 속도가 매우 떨어짐. 프로그램 이식성↓, But, 속도는 빠르다.

컴파일러가 등장하면서 CPU아키텍처에 따라서 컴파일러 프로그램만 만들면 되고 기존 코드는 재작성할 필요 x (이식성↑)
But, 어셈블리어로 작성한 코드보다는 속도가 떨어질 수 있음.
