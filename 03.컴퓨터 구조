Chapter1. 컴퓨터 시스템의 이해
컴퓨터 구조 학습 이유
-현대의 컴퓨터는?  : 시간이 지나면서 컴퓨터란 기계가 인간에게 다가오는 역할이 달라지고 있다.
-상태머신(state machine) : 컴퓨터가 취하는 상태는 정해져 있다. 자료 입력받고, 프로세스 처리하고, 저장하고, 결과내주고 그 기본적인 상태가 상태머신이다. 그걸 갖고 컴퓨터에 여러가지 일을 시킨다. 겜도 하고, 서핑도 하고, 이런걸 하려고 컴퓨터에 소프트웨어를 구축시키는데, 소프트웨어는 되게 다양하다. 이 다양한 소프트웨어를 상태머신이라는 기계에다가 어떻게 효율적으로 일을 시키기 할건지가 컴퓨터 구조와 밀접한 관계이다.
ㄴ 상태머신 갖고 소프트웨어 구동 시키는데 가장 중요한 건 고성능, 저전력, 리소스 적게 쓰는 것. 
-결국 도메인(Domain)의 문제 : 도메인은 예를들어 대기업에서 컴퓨터 관련 직종 뽑을 떄 전산과 관련만 뽑는게 아니고 컴퓨터 이용해서 토목,sale 등 이런것들을 다 해야한다. 이런거 하나하나를 도메인이라고 한다. 그런 도메인의 시작은 컴퓨터 구조가 기본 (?)

컴퓨터의 구성 = 하드웨어(State machine) + 소프트웨어( 시스템소프트웨어(OS) + 응용소프트웨어(엑셀 등) ) 
하드웨어는 하는 일이 일정하다. OS는 응용소프트웨어와 하드웨어의 중간자 역할. 호환성 문제 해결해준다.
하드웨어는 입력장치와 출력장치가 제일 기본적이다.  ( 입력했으면 나오기 까지의 과정 = 프로세스) 

프로세스는 기본적으로 주기억장치( 책상 위) 에서 처리되고, 처리된 내용이 보조기억장치( 서랍 안)에 담겨진다.  처리 될 때 보조적인 도구가 필요한데 그게 제어장치, 연산장치(계산기)  : 책상위에서 계산기 같은거 도움받아서 작업하다가 서랍안에 넣어놓는다.

컴퓨터는 기본적으로 계산한다는 어원을 갖는다

정보화 사회에 대한 이해
-인류사회학적 측면 : 신석기 시대 농업혁명 ->18세기 산업혁명 ->2차 산업혁명(전기,생산라인) -> 3차 산업혁명(컴퓨터,통신)
                                 -> 21세기 4차 산업혁명(IOT,공장자동화 , AI , Big data, 머신러닝, 딥러닝 등..)데이

데이터의 표현
정보(information)  : 어떤 사물에 대한 소식이나 자료. 가공된 데이터. 데이터가 프로세싱되면 정보가 된다.
데이터(data) :  정보를 작성하기 위해 필요한 자료나 정보를 처리하거나 전송할 때 binary나 디지털과 같은 좀더 편리한 형태로 바껴진 자료. 정보의 원재료

수치데이터(Numerical data ) :연산용 데이터. 프로세싱을 하는데 가장 기본이 되는 내용
비수치 데이터 (Alphanumerical data) : 입출력용 데이터. 수치데이터들을 입출력 하기 위해 살짝 변형을 하거나, 입출력 전용으로 쓰이는 데이터로 바꾼것.
                                                               비수치 데이터는 '문자' 라고도 얘기함. 그냥 수치가 아닌 데이터 . ex)나이, 소속 같은
특수문자(special character ) : 입출력/연산용 데이터

-비트는 0과 1로 표현된다. 컴퓨터는 전기로 구동된다. 전기는 state가 있다/없다로 표현되어서 2진수 체계로 표현한다.
비트는 길어지면 보기 피곤해서 8개씩이나 16개씩.. 잘라서 쓴다. 비트 8개 묶으면 1byte
-워드는 삼성이나 모토로라 처럼 기계마다 다르다. 


컴퓨터 구조란 어떤 과목인가?
컴퓨터 패러다임의 변화 :  컴퓨터의 태동 -> 사무자동화 기계로 인식되던 시대 -> 네트워크의 단말. 통신기기의 반열 
->미래는 유비쿼터스(Ubiquitous) 시대의 도래, Wireless , IOT, 스마트 컴퓨터,....

컴퓨터의 태동
초기의 계산기 : 주판 -> 파스칼의 계산기1642 -> 라이프니츠의 계산기 1671 -> 찰스배비지 차분기관,해석기관1822 (전기없어서 구동 못함) 
근/현대 컴퓨터: ->에이킨의 MARK-1(1944) -> 머클리&에커트의 ENIAC(1946, 폰노이만식 기계. 데이터와 프로그램이 시스템에 같이 들어가서 처리. MARK1은 사람이 데이터와 프로그램의 중간역할을 해줘야 했다. ) -> 스마트폰 -> AI( 딥러닝, 머신러닝 정도. 알파고같이 특화된 분야에 깊이있게)

사무자동화 기계로 인식되던 시대 - cpu1개로 충분
자료준비기기(워드,복사기,프린터)/자료처리기기(워드프로세싱,개인용컴터) /자료전송기기(팩스 ,이메일,원격회의sys) / 자료저장기기(마이크로필름,디스크)

네트워크의 단말
요즘은 네트워크 단말로 컴퓨터의 역할이 변했다.
인터넷 세계관에 의하면 인터넷 망은 edge(주변부)와 core(중심부)로 구성

access net : 집에있는 컴퓨터에서 인터넷 쓸 때 집근처에 있는 케이블 티비 회사나, KT 같은 업체.
ISP : 인터넷 회선 지원 업체들이 전세계적으로 연결하기 힘들다. 그래서 그 사업이 바로 ISP. Internet Service Provider. 다국적기업. 전세계엥 12개정도.
IXP : ISP가 12개 밖에 없으니 그 빈틈을 공략하는 업체 . Internet Exchange Point.
regional net은 없어도 되긴 하지만 더 빠르게 하려고 쓴다.

유비쿼터스(Ubiquitous) 시대의 도래
우리가 사는 세계를 가상의 세계에서 다 이뤄진다는 컨셉. 실생활과 가상세계가 구분이 없어지는 세상. 실세계의 맵핑
외국은 IOT랑 별 차이를 안두기도 함. 우리는 유비쿼터스 시대 다음이 IOT시대.

Mobile & Wireless 전성시대
-유선 사업자와 스마트폰 사업자의 위상이 변화했다. 
-컴퓨터 구성요소가 병렬 프로세싱(멀티 프로세싱,pipeline)으로 변화
-wireless access point는 54Mbps / wired Ethernet은 100Mbps

IOT : Internet of Thing . 사람,사물,공간,데이터 등 모든 것이 인터넷으로 서로 연결되어, 정보가 생성/수집/공유/활용되는 초연결 인터넷
        모바일 base에서 IOT, Cloud, Bigdata가 연계된 새로운 가치와 서비스 창출.
인공지능 : AI . 컴퓨터에 의한 활용으로 인간의 추론적 기능과 지능적인 행동을 재연하려는 시도. 
                 지금까지는 사람이 기계를 관리하였지만, 이제는 기계가 기계를 관리 (M2M)


컴퓨터 구성요소의 기능 및 이해
중앙처리장치 (Central Processing Unit) = 두뇌
    CPU  : 마더보드(데이터의 전달통로가 디자인 되어있는 메인보드)에 보통 산술논리연산장치(ALU)와 제어장치(Control Units)로 한 칩으로 구성.
              실행프로그램이 명령 해석, 실행, 장치 제어 ,ALU, CU, 각종 레지스터로 구성
    MPU : Micro Processor Unit . CPU를 LSI(고밀도 집적회로)화 한 일종의 통합장치. CPU 여러개 묶어놓은 것.
               MPU의 발전으로 멀티프로세싱등이 가능해졌다.
               - CISC(Complex Instruction Set Computer ) - 소프트웨어를 처리해주는 기능들이 일반적으로 기본적인 동작들이 반복적이고, 동일한데,
                                                                                     그런 명령을 일일이 소프트웨어 처리하지 않겠다는 것. 그냥 하드웨어로 처리하겠다는 컨셉
               - RISC(Reduces Instrunction Set Computer) -CISC의 반대. 
               - Bit Slice MPU : CISC, RISC 이 두 종류의 MPU를 적절히 원하는 만큼 작게 쪼개서 조합시키는 MPU
    IOT 디비이스 H/W 플랫폼 종류 : Arduino (아두이노) - 대표적인 오픈소스 H/W플랫폼.  집에있는 냉장고, 청소기 같은거에 심는 것. 

주변장치(Peripheral Device)  - CPU의 주변장치
     기억장치(Memory Unit) 
      -RAM(random access memory) : 칠판 같은 것. 효율적으로 관리. 컴퓨터 끄면 정보 날라간다. 작업대/책상 이라고 생각! . DRAM/SRAM이 있다.
      -ROM(read only memory):부팅할 때,ROM bias 로 CPU가 하드디스크의 OS 불러온다. 지워지지 않음. 외부 프로그램 불러올 수 있게끔 작동하는 기억장치
     보조기억장치(Auxiliary memory device)
          -하드디스크, 자기테이프, CD/DVD, 블루레이
              ㄴ디스크 접근시간 = 탐색시간(헤드를 해당트랙으로) + 회전 지연(idle time) + 데이터 전송시간
          -속도가 느리고, 가격은 저렴하고, 다량의 데이터 저장 가능, 부피가 크다.
          -보조기억장치에 있는 정보를 불러들여서 주기억장치에서 작동. 처리된 결과를 담는 서랍과 같은 개념. 
          -최근 보조기억장치
                 플래시 기억장치 : EEEPROM(전기로 flash)의 한 종류 . RAM과 ROM의 중간 위치. CF(Compact Flash)메모리/SSD(Solid State Drive)
                  USB, SD card(Secure Digital Card) , 메모리 스틱(SONY 꺼)  
     관계 
          1.전원 부팅 시 CPU가 자동으로 ROM에 있는 프로그램 실행(OS불러오기)  -> 2. 보조기억장치에 있는 정보를 RAM에 load(적재) 시킨다.
         -> 3. 메모리로 부터 실행할 명령어와 데이터를 CPU에 갖고 와서 처리 -> 4. 처리 후 결과는 RAM에 갔다가 보조기억장치에 save.
    입출력 장치
         키보드,마우스,스캐너, 터치스크린, 조이스틱, OMR, 바코드 reader


컴퓨터 구조와 통신
컴퓨터의 발전은 컴퓨터만의 발전이 아니고 인터넷을 하는 기계라는 인식이 더 크다. 혁신적 네트워크 발전에 발 맞춰서 발전한다.

비즈니스 환경에서의 통신과 네트워킹의 역할
80년대 이후 지속되고 있는 급속한 정보통신기술의 발전으로 컴퓨터구조의 변화도 발전과 새로운 시장 구도를 변화시키고 있는 상황
급속한 정보통신 기술의 발전은 무선과 통방융합 
통방융합이란 원래는 주파수 대역마다 처리하는 기계(라디오같은)가 달랐는데, 이게 다 디지털화 되어서 모든 기계에서 가능!
->예전처럼 OS가 컴퓨터 시스템 관리 운영체제뿐 아니라 전체적인 네트워크 환경까지 지원해주는 역할(NOS-Newtwork(new,next) OS)

네트워크 장비는 4차 산업혁명을 실현하기 위한 핵심 인프라.
유/무선, 통신/방송 및 통신/컴퓨터의 융합 등 컨버전스 가능. 
대용량의 통신회선 교환 가능. 
사용자 중심의 신기술이 활발하게 개발됨.

-예전엔 아날로그 신호였는데 요즘은 다 디지털 신호로 바껴서 컴퓨터 처리가 가능하고 세상의 모든 기기에 적용가능하다
-5G가 정작히 되어야 4차 산업혁명이 가능하다. 핫이슈는 스마트 팩토리. (헬스케어, 핀테크,자율주행, 스마트시티 등)

양자 컴퓨터
-듀얼코어는 CPU가 2개 있고 , 쿼드코어는 4개다. 근데 컴퓨터는 순차적으로 step by step에 적합화 되어있다. 쿼드코어는 4개의 task가 다 따로 한다는 건데 그럼 기계는 그 능력이 되는데 프로그램은 어떻게 할까? 그 동시에 처리하는것에 대해 해결하기 위해 나온게 양자컴퓨터다.
-일반적 컴퓨터는 step by step이 익숙하지만 양자컴퓨터는 동시병렬처리. 
-중첩(superposition), 얽힘(entanglement)등 양자의 고유한 물리학적 특성을 이용해, 다수의 정보를 동시 처리하는 새로운 개념의 컴퓨터
-현대 반도체 칩의 미세회로에서 발생하는 누설전류로 인한 고전컴퓨터 성능 한계 돌파를 위한 대안으로 필요성 대두
-비트의 개념보단  양자비트, 큐비트를 정보 처리단위로 쓴다 - 연산 속도가 지수함수적으로(급격하게) 증가해 빠른속도로 문제해결 가능
-양자 병렬성 ( quantum parallelism) : 단 한번에 모든 숫자의 연산을 수행할 수 있는 성질
    if 세개의 2진수가 입력값이고 결과를 찾는거라면, 기존 컴퓨터는 8(2의3제곱)번 연산해서 찾지만,
         양자컴퓨터는 광자 3Qbit를 얽힘 관계로 생성하는 순간 모든 경우의 수를 계산해서 1번만에 끝난다.

글로벌인터넷
web1.0 -> web2.0(개방, 참여정신을 바탕으로 하는 쌍방향 웹기술) ->web3.0(시맨틱 웹기술(문법분석?)을 활용하여 웹페이지에 담긴 내용 이해하고 , 이로부터 개인 맞춤형 정보를 제공하는 지능형 웹기술) -> web 4.0 (현실과 가상의 세상이 연결되는 초 연결 지능화 웹기술)


Chapter2. 데이터의 표현
데이터의 종류
디지털 정보의 단위
-1nibble = 4bit  / 1byte = 8bit /  영어 1문자는 1byte , 한글은 2byte / 1워드 = 특정 CPU에서 취급하는 명령어나 데이터의 길이에 해당하는 비트 수(8의배수)
-LSB : 1byte내에서 최하위 비트 Least Significant Bit
-MSB : 최상위비트 Most Significant Bit

진법
-2진법 : 0과1 두가지 기호로 표현. 전기의 신호는 0과1이니깐 컴퓨터는 이걸 사용.
-8진법(Octal)과 16진법(Hexadeciaml)은 10진수와 2진수간의 번역을 더 원활하게 해주려고 채택되고있다.
ex) 컴퓨터 내부의 주소값(번지값)들은 기본적으로 2진수로 쓰기가 너무 복잡해서 16진수로 쓴다.

2진수 0000 ~1001 = 10진수 0~9 = 8진수 0 ~ 11 = 16진수 0~9
2진수 1010 ~ 1111 = 10진수 10~15 = 8진수 12~17 =16진수 A~F(10~15)

- 10진수->2진수 : 10진수를 2로 나눠서 나머지를 순서대로 뒤에서 부터 적고, 2가 안나눠질때 마지막 몫은 1이다. 1을 맨앞에 붙인다
     ex ) 34를 2진수로: 34를 계속 2로 나눈다. 34/2 =17..0 ,17/2=8..1 , 8/2=4..0 , 4/2=2..0, 2/2=1 ->10010
- 2진수 -> 10진수  : 10010 = 1*2^5 + 0*2^4 + 0*2^3 + 0*2^2 + 1*2^1 + 0*2^0 = 34
- 8/16진수 -> 2진수 : 8진수는 3자리씩 묶어서 처리, 16진수는 4자리씩 묶어서 처리
    ex) 8진수 757 <-> 2진수 111/101/111   |   16진수 1EF <-> 1/1110/1111
-분수(실수)의 2진수 변환 : 정수부분은 똑같이 하고, 소수부분만 2를 곱해서 소수점 자리가 0될때까지 해서 곱한결과의 정수부분 붙인다.
    ex) 0.75 => 0.75 * 2 = 1.50 -> 0.50 *2 = 1.0  / 0.75 = 0.11

보수(Complement)
-굉장히 유용하게 많이 쓴다. 보수로 음수 표현하거나, 덧셈을 뺄셈으로 표현하거나 할 수 있다.
-최대값(해당 bit에서 가장 큰 표현형)을 형성하는데 서로 보완 관계에 있는 두 수 사이의 관계를 1의 보수(One's Completment)라 한다.
-MODULUS(최대표현자리수)를 형성하는데 서로 보완관계에 있는 두 수 사이를 2의보수(Two's Complement)라 한다.
ex) 1의보수 : 두자리 수로 표현할 수 있는 가장 큰건 99. a,b 두 수가 있다고 할때 a+b - 99 이면 a와b는 1의보수 관계
      2의보수 : 두자리 수로 표현할수 있는 숫자의 갯수는 100개. a+b=100이면 a와b는 2의보수 관계
-2진수로 확장시키면 더 수월. 2진수 1의 보수에 +1 하면 2의 보수이다. 1의 보수는 자신의 수를 반대(1<->0)로 바꾸면 됨.
    ex)1의보수: a+b=1 , a+b=11 , a+b =111 / 2의보수 a+B = 10, a+b = 100, a+b = 1000

정수(고정소숫점, Fixed Point Number) 표현
-소숫점의 위치가 고정되어 정해져 있는 수.
-첫번째 비트(sign bit, 절대치)가 부호값이다. 0이면 + / 1이면 -
-표현범위 : -(2^(n-1)-1) ~ +(2(n-1)-1)
- +0과 -0 둘다 공존한다는 한계가 있다.
-> 해결하기 위해 2의보수에 의해서 정수 표시  : -0이 없다. 1111+1 = 10000인데 4자리수로 정해져있음 앞의 1표현 못해서 그냥 0000 = +0
-2의 보수 표현범위가 -0이 없기 떄문에 1개 적다.
-10진수형 정수표현 중 Unpacked Decimal(Zoned decimal)은 연산에는 이용 될 수 없으나 입출력 가능하고 Packed Deciaml은 연산에 이용. 입출력x

실수(부동소수점, Floating-point)
- N =(-1)^s * M * 2^E

-맨앞 비트는 부호비트. 1이면 음수.
-그다음 7비트는 지수필드(E). 나머지는 기수필드(M) . 윗 그림은 +5 + 0.1001*2^5
ex) -314.625를 표현하면, 일단 -니깐 sign 비트는 1 , 314.625를 2진수로 하면 100111010.101 이 된다.
     여기서 소수점을 맨앞으로 옮겨서 1.00111010101 * 2^8 을 만들고 소수점 밑의 자리를 기수필드에 채우면 된다. 여기서 지수는 8이나왔다. 
https://codetorial.net/articles/floating_point.html


디지털 코드
-BCD코드(Binary Coded Decimal Code : 2진화 10진코드, 8421코드)

-3초과 코드(excess-3코드) : 3을 더한 코드.통신할 떄 통신이 안들어오면 sleep모드인데 그게 0이들어오면 awake 모드랑 구분이 어려움. 근데 3초과 코드는 0011이 들어오니깐 아 awake 모드구나 알 수 있다.( 0000 + 3 = 0011)


에러검출코드
-패리티 비트 : 오류검출에 사용되는 코드체계. 요즘은 잘 안씀. 
                        짝수 패리티는 1의갯수를 짝수개로 맞춰주는거고, 홀수패리티는 1의갯수가 홀수개로 맞춰주는 것.
                        ex) 1000001 -> 짝수패리티는 0100001 , 홀수 패리티는 11000001
-해밍비트 : 어느부분에 어떤오류가 있는 지 발견하는 코드체계


논리회로와 데이터 표현
사람은 10진수를 쓰고, 컴퓨터는 on/off를 표현해야하니깐 1과0의 2진수를 쓴다. 둘의 소통을 위해서
1. 진 이진수 (pure binary) : 2로 나누고 곱하고 해서 서로 표현하는 것. 연산이 가능함.
2. 코드화 변환 : 입력과 출력을 하는 경우는 연산이랑 크게 관련이 없어서 넣고 빼는 기능만 강조하다 보니깐 진이진수 보다는 코드화(BCD코드 등..)
3. 정.실수&연산용 변환 

-소수를 2진수로 표현할 때 순환반복이 되는 경우가 있다.
ex) 45.3 을 2진수로 표현하면 소수 부분이 0.3x2 =0.6 / 0.6x2=1.2 / 0.2x2=0.4/ 0.4x2=0.8/0.8x2=1.6 / 0.6x2=1.2 ...... 계속 반복된다.
이럴땐 컴퓨터에서 허용된 자릿수까지만 반복허용. 유효한 부분까지 만 표시. 정확하진 않지만 별 차이 없다.

보수
1.비트수가 고정되어있을때 양/음수로 활용
    양수와 음수로 표현할 땐, 맨 왼쪽의 비트가 0일땐 양수, 1일땐 음수

1의 보수는 0의 보수가 -0인 문제가 생긴다.
2의보수는 0의 보수가 1111이면 거기서 +1해줘야하니간 10000이면 캐리비트가 발생해서 4자리수만 표현해야해서 잘려서 0000 ->0. 결국 0의 표현은 하나
2의보수는 다 세트가 되는데 -8 하나가 남는다. 음수표현이 하나 많다!

2.연산에 활용
뺄셈의 연산을 덧셈으로 처리가능 -> 컴퓨터는 기본적으로 덧셈이다! 곱셈 2x3도 2+2+2 이렇게 계산한다.
ex) 32-12= 20        =>     32 + 87(1의 1의보수 8, 2의 1의보수 7) = 119 ->119 + 1 =20
      1011 - 0010 = 1001   =>    1011 + 1101 = 11000  -> 11000 + 1 = 11001


논리게이트(Logical gate)
-논리연산을 수학적으로 표현하는 하드웨어. 
-논리적으로 입출력.
-논리게이트 같은 이런 게이트들이 수천개 모여서 컴퓨터 구성
-논리게이트는 논리연산(<->산술연산)을 수행하는 전자소자로서 주어진 입력 변수 값에 대하여 정해진 논리함수를 수행하여 그 함수의 연산 결과와 동일한 결과값을 출력하는 하드웨어 
-샤넌의 스위치이론(1983) : 스위치 연결되면 1 , 연결 안되면 0
-논리연산의 기본 표현
    1. 논리곱(AND 게이트) - 둘다 1일때만 결과 1.     X = A ·B ( AND 게이트의 대수적 표현) = A X B
     
    2. 논리합(OR게이트) - 하나라도 1일때 결과 1 .   X=A+B 
     
    3. 논리부정(NOT 게이트)  : X= Ᾱ
     
     4. 배타적 논리합 ( XOR 게이트) :  X = A ⊕ B  = AB(위에작대기) + ᾹB . 값이 서로 다를 때 1
     
     -실무 적용 사례
      1bit 덧셈 구현 (논리 회로를 이용한 반가산기(Half adder) 구현) . a +b =S 라는 기본연산 구현
      1) 단일 비트에 의해 예측 가능한 연산 결과에 대한 진리표를 구한다.
        
      2) 작성된 진리표를 구현할 수 있는 부울대수식을 구현
           S값을 보면 배타적 논리합임을 알 수 있다.  S = a ⊕ b
          C값은 논리곱임을 알 수 있다. C = ab
      3) 논리게이트를 이용한 회로 구성 = 반가산기(half adder) 가 이렇게 구성된다.
         

부울 대수와 논리식의 간편화  
부울대수(Boolean Algebra) : 참과 거짓을 판별 할 수 있는 논리적 명제(T/F구분문장식)를 수학적 표현의 논리 전개 식으로 구현(1852 G.Boole)
-논리 회로의 형태와 구조를 기술하는 데 필요한 수학적인 이론
-부울대수를 사용하면 변수들의 진리 표 관계를 대수식으로 표현하기에 용이
    ㄴ 진리표를 간략하게 만드는게 중요하다! 진리표로 회로를 만들고 칩을 만들고 하므로.
-동일한 성능을 갖는 더 간단한 회로를 만들기에 편리하다.
-부울대수의 기본법칙
     1) 교환 법칙 (commutative Law) : AB = BA  / A+B = B+A
     2) 결합 법칙 (Associative Law) : A(BxC) = (AxB)C   / (A+B) + C = A + (B+C)
     3) 분배법칙 (Distributive Law) : A(B+C) = AB + BC
     4) 드모르강의 법칙 ( De Morgan's Theorem)   = 집합산에서 A∪B 에 bar 하면 A∩B
          
- 부울대수를 이용한 간략화 예
E= (a' +bc)(a+b) = aa'+a'b+abc+bbc = a'b+abc+bc = (a+1)bc+a'b = bc + a'b
ㄴ bb는 B∪B=B인거처럼 그냥 b 이다. / a+1은 a가 0이든 1이든 1이다.

카노(Karnaugh)맵
-부울대수는 간단하지만 여러 규칙이 있다. map 방법은 부울 함수를 곧바로 간소화 할 수 있어 널리 활용된다.
-만약 변수가 n개 라면 카노맵은 2^n개의 민텀(minterm)으로 구성된다.
-각 인접 민텀은 하나의 변수만이 변경되어야 한다. ( aa - a'b - a'b').
     ㄴ그래서 순서가 맵 보이는대로랑 다르다. 보이는건 b'c'가 먼저고 bc'가 다음인데, 순서는 bc'가 먼저다.
-출력이 1인 기본 곱에 해당하는 민텀은 1로, 나머지는 0으로 표시    
ex)변수가 4개인 경우
-간편화 예 ) E = a'b + abc + bc 부울식의 간편화
1) 주어진 식에서 민텀을 찾아 1로 표기 / 2) 인접 민텀끼리 묶기 -> bc + a'b'


조합/기억 논리회로
조합논리 회로
-입력값에 의해서 어떤 도출되는 결과를 만들 수 있는 하드웨어적인 내용. 여러게이트 또는 단일게이트(?)
-조합회로는 입력과 출력을 가진 논리게이트의 집합으로 , 출력은 현재의 입력(0,1)값과 조합의 함수이다
    ㄴ조합 논리회로 갖고만 안되고, 그 내용을 기억할 수 있는 기억회로가 있어야 한다. ->플립플랍 필요(cf. 플립플랍 여러개 묶어두면 레지스터)
-설계절차 : 문제제시 -> 입력/출력 변수에 문자기호 붙인다 -> 입/출력 사이의 관계를 정의하는 진리표유도
                   -> 각 출력에 대한 간소화된 부울 함수 얻기 -> 논리도 작성
-대표적 조합회로
    1)가산기(Adder) : 두개(그 이상)의 입력을 받아 결과물을 출력하는 조합논리 회로 .
                                 반가산기는 주어진 비트와 비트사이에 연산이 가능한 것. 1bit가 주어지니깐 만약 연산 시 캐리비트 발생하면 처리가 안됐다
                                 ->그래서 가산기 쓴다.    full Adder는 half adder 두개 합치고, 캐리비트의 내용이 포함되는 3변수 식.
     
    2)멀티플렉서(Multiplexer) : 다수의 입력 선 중 하나만을 선별적(시그널 조작)으로 출력 가능하게 해주는 조합논리 회로
     
    3)디멀티플렉서(Demultiplexer) : 하나의 입력 선(값)을 다수개의 출력선으로 분해하는 기능의 조합회로(멀티플렉서 역 기능)
    예를들면 십진수 3을 input 했을 때 , 2진수로 표현할 때 0011이렇게 4자릿수로 표현하니깐 4개 출력해주는 디멀티플렉서 쓴다.?
     

기억회로의 구성 및 작동원리
대부분의 디지털 시스템들이 조합회로를 가지고 있는 것은 사실이지만, 대부분의 경우 순차회로로 구현되는 저장요소를 필요로 한다.
우리는 이러한 종류의 회로를 플립플롭(Flip Flop)이라고 한다.

순차회로
-순차논리회로는 게이트뿐만 아니라 기억능력이 있는 플립플롭으로 구성된다.
-플립플랍과 게이트를 서로 연결한 것!. 게이트들로만 이뤄진 회로는 조합회로지만, 플립플롭이 포함될 떄 순차회로가 된다. 

-순차회로의 외부출력은 외부입력과 플립플롭의 현상태의 함수로 표시된다.
-순차회로의 특성은 입력,출력 및 플립플랍의 상태로 부터 특정지어진다.
-출력과 다음 상태는 모두 입력과 현 상태의 함수이다. 이 사이의 관계를 상태표, 상태표를 그림으로 도사한것이 상태도.



Chapter3. 중앙처리장치
CPU 내부 구조와 레지스터
기억장치로서 플립플랍이 굉장히 중요한 장치! 플립플랍이 여러개 모인게 레지스터다. 그런 레지스터들이 상호 어떻게 연결되고 그런걸 배운다.

CPU 구성요소
- 컴퓨터에서 데이터 처리동작을 수행하는 부분을 중앙처리장치라고 하며 줄여서 CPU(Central Processing Unit)라고 부른다. 
- 듀얼코어, 쿼드코어...여기서 코어가 CPU이다. 사람의 두뇌와 같다.
- CPU=  레지스터 세트 + 산술논리장치(ALU:Arithmetic Login Unit) +제어장치(Control Unit)으로 구성
              ㄴregister set는 플립플랍의 모임이니깐 필요한 데이터 보관하는 곳.
                 Control Unit : RS(register set)간 정보전송 감시, ALU에게 수행할 동작을 지시
                 ALU : 명령어를 실행하기 위한 마이크로 연산 수행
- 마이크로 연산 : 컴퓨터 내부에서 돌아가는 명령어를 실행하기 위해 실행되는 연산이 마이크로 연산.<->매크로동작(워드프로그램 열거나 하는 것) (사람이 살아가면서 생각하고 운동하고 얘기도하고 이런 행동들은 외적인 행동, 그런 행위를 하는 동안도 내부적으로 심장도 뛰고, 피는 돌고 그런 자율신경계가 돌아가야 생명이 연장된다.  )
-CPU 내부구조
     
    MAR(Memory Adress Register) :  메모리 상태체크
    MBR(Memory Buffer Register) : 메모리에 저장하기 전에 들어오는 임시 저장공간.메모리 저장 전에 MAR의 명령을 받아서 어디로 들어갈지 정하고 그런것
    PC(Program Counter) : 프로그램 계수기. 다음에 수행될 명령어가 들어있는 주기억장치의 주소를 기억하고 있는 레지스터로
           IC(instruction Counter : 명령어 계수기) 혹은 LC(location counter: 위치 계수기)라고도 부른다.
    IR(Instrunction Register) : 명령레지스터. 프로그램 계수기(PC)가 지정하는 주소에 기억되어있는 명령어를 해독하기 위해 임시 기억하는 레지스터
    명령어 해독기(instruction decoder) : IR에 들어있는 명령코드의 해석 (각종 명령코드->제어 신호화 하여 기계 사이클로 전송)을 담당하는 논리회로
    CU 제어장치(control unit) : ID로부터 보내져온 신호에 따라 명령어를 실행 (clock에 의해 발생)
    GPR 범용레지스터(general purpose register) : 작업레지스터에서 data가 용이하게 처리되도록 임시로 자료를 저장하는 경우 사용. common퍼포먼스 같은
    WR 작업레지스터(working register) : 산술논리연산을 실행할 수 있도록 자료를 저장하고 그 결과를 저장(GPR과 차이점은 ALU연결 여부).
                                                         처리된 중간값 기억. 캐리비트 같은 것.
    SR 상태레지스터 (status register) : CPU의 상태를 나타내는 특수목적의 레지스터 - 연산결과의 상태, 영Z(zero), 부호S(sign),
                                                           오버플로우V(overflow : 10공간에 12가 들어오면 치명적), 캐리 C(carry) , 인터럽트 I (interrupt). 현재 상태 체크

위의 사진에서 fetch는 작업이 일어나는게 아니라 단지 데이터를 이동시키는 내용.
1. PC에서 명령실행해야하는데 필요한 자료를 MAR에 통보
2. MAR에 정보에 의해서 MBR 이동
3. MBR에서 작업할 수 있는 IR 로 넘겨주고
실제로 컴퓨터에선 데이터가 들어올때 박스안에 OPCODE + data로 들어오는데 data는 IR에서 받은 데이터고 decoder가 앞에 OPCODE를 보고 뭘해야하는지 해독한다.


CPU 내부 구조와 명령어 집합
명령어(instruction) 구성과 실행
레지스터 전송문 (레지스터 상호 간에 정보 주고받는 문장) 으로 나타내어지는 기본 컴퓨터의 각 연산이 어떻게 동작하는지를 알아본다.
ㄴ 여기서 연산은 사칙연산도 물론 포함이지만, 인접해있는 레지스터끼리 필요한 명령문을 주고 받는 행위다. 그 행위로 인해 어떤결과가 나오는 것!
     = Micro Command Operation = Instruction Operation
컴퓨터(CPU)의 구조는 내부레지스터, 타이밍과 제어구조 명령어 집합에 의해 정의된다.

-사실 컴퓨터는 CPU와 주변장치다.
-정보를 기억하는 단위가 플립플랍이다. 64비트 씩 이렇게 묶어야 하니깐 그 컨셉이 레지스터.
-조합논리회로는 더하기,빼기, 곱하기, 멀티플렉서 개념
-순서논리회로=  조합논리회로 + 플립플랍 ->CPU

-레지스터에 저장된 데이터의 조작을 위해 실행되는 동작을 마이크로 연산(micro-operation) 이라 한다. 이는 하나의 클럭 펄스 내에서 실행되는 기본동작
 ex)시프트(shift:한자리씩 옆자리로 이동) ,카운트 (count), 클리어(clear:기억공간 클리어), 로드(road:작업하려고 기본적인 내용 불러오는것. 연필을 작업대로)
-디지털 컴퓨터의 구조를 정의하기 위해 논의되어야 할 내용
    ㄴ레지스터의 종류와 그 기능
    ㄴ레지스터에 저장된 이진 정보를 갖고 수행되는 일련의 마이크로 연산들
    ㄴ일련의 마이크로 동작을 온/오프 시킬 수 있는 제어기능
-시프트 할건지, 클리어 할건지, 더할건지, 뺄건지 이런게 다 마이크로 연산들.
-마이크로 연산은 가능하면 종류가 안많은게 좋다. 너무 복잡해서! 
-마이크로 연산(내부)을 통해서 매크로 동작(외부)이 일어난다.
-하드웨어 구성은 명령어들이 어떻게 구성되었느냐에 따라서! 하드웨어 구성 전에 어떤명령어를 어떻게 쓰는지.

-레지스터 표현들

R2<-R2      :      치환 연산자(replacement)를 이용한 레지스터간 정보 전송
P:R2<-R1      :        if(P=1) then (R2<-R1) . 목적 레지스터에 조건부 처리가 가능하도록 병렬 로드 기능이 있어야 한다.
★레지스터 전송을 나타내는 각 문장들은 그 전송을 수행하는 하드웨어가 구성되어 있음을 의미

-레지스터 전송의 기본 기호

R2(0-7) : 두번째 레지스터에  0번부터 7번까지
R2(L) : Low bound
R2<-R1 , R1<-R2 : R1 레지스터에서 R2레지스터로 정보전송. 동시에 R2레지스터에서 R1레지스터로 정보 전송. 병렬처리

-CPU구성하는데에, 커맨드의 종류, 커맨드와 커맨드가 어떻게 연결되느냐, 커맨드 수용할 수 있는 하드웨서 구성 되어있다. 이런거 알아야
-커맨드는 기본적으로 하드웨어다. 하드웨를 구동시키는 명령지시서는 소프트웨어. 문제는 소프트웨어의 변동사항이 수시로 바뀐다. 그럼 그때그때 하드웨어도 바껴야되나? -> 하드웨어와 소프트웨어는 독립적. 서로 영향 최소화해야.

CPU(central processing unit) 디자인
직접연결 : 연결 복잡도가 장치수의 제곱에 비례. 많아질수록 복잡하다. n(n-1)/2 ~ n^2
버스연결 : 공용선에 의한 연결. 가장 가성비 높은 연결 방식. 관리를 위한 다양한 방법이 제시됨.(token, polling..?)

공용선에 의한 레지스터 상호 연결 예
1)멀티플렉서 - 여러 선중에 하나만 선택

2) 3-상태 버스 버퍼 - 기억하는거?

디코더(decoder) : 코드화 된 데이터로부터 정보를 찾아내는 조합논리회로

스택(stack) : 자료의 입력과 출력을 한 곳으로 제한한 저장구조. LIFO . push/pop 쓴다. ex)주함수에서 서브루틴 호출할경우, 문자열의 역순출력, 연산자 후위표기. CPU에서 자료저장되는 형태중에 가장 선호되는 구성이 Stack ->커맨드가 간단해짐. 
큐(queue ) : 입력과 출력이 각기 서로 다른 부분에서 진행 .FIFO . put/get 쓴다. ex)버퍼등과 같이 순차적 처리를 요하는 자료의 대기 시 활용
데크(deque): 스택과 큐의 동작을 동시에 가능하도록 디자인된 자료구조 형태 .ex)입력제한 데크-스크롤(scroll), 출력제한데크 - 셸프(shelf)


마이크로 명령과 ALU
마이크로 연산은 레지스터에 저장된 데이터에 대해 수행되는 기본적인 연산으로 디지털 컴퓨터에서 흔히 사용되는 마이크로 연산은 4가지로 분류
- 레지스터 사이에서 이진 정보를 전송하는 레지스터 전송 마이크로 연산
- 레지스터에 저장된 수치 데이터에 대해 산술 연산을 수행하는 산술 마이크로 연산
- 레지스터에 저장된 비수치 데이터에 대해 비트 조작 연산을 수행하는 논리 마이크로 연산
- 레지스터에 저장된 데이터에 대해 시프트 연산을 수행하는 시프트 마이크로 연산

산술 논리 연산 장치 ( Arithmetic Login Unit : ALU) - 산술 연산과 논리 연산
-주로 정수 연산을 처리
-부동 소수(Floating-point Number) 연산 : FPU (Floating-Point Unit)인데 , 최근에는 ALU가 부동 소수 연산까지 처리
-어떤 커맨드를 하고, 어떻게 커맨드를 연결하고 하는 것에 의해서 CPU가 만들어지고 CPU에서 가장 중요한 역할 하는게 ALU. 실제 연산이 일어나니까
    (전달, 메인에서 서브 호출, 서브에서 메인 콜백 등등)
-산술연산 : 덧셈, 뺄셈, 곱셈, 나눗셈, 증가, 감소, 보수
    ㄴ 산술연산 시 가장 중요한게 ALU와 버퍼! ALU에선 실제 연산이 진행되고 , 버퍼는 그 결과를 일시적으로 기억.
-논리연산 : AND ,OR ,NOT, XOR, 시프트(shift)

-산술연산 ( ADD, SUB, MUL, DIV, INC , DEC , NEG ) 
    
-논리연산과 산술 시프트 연산 ( 값 전체가 아닌 비트 대 비트 연산) ( AND, OR, NOT, XOR, ASL, ASR, LSL, LSR, ROL, ROR )

MSB(Most Significant Bit) : 최초비트 . 맨왼쪽 / LSB(Least Significant Bit) : 최후비트 . 맨오른쪽

논리연산 예
-AND 연산자로 MASKING : 00001111을 갖고 하위비트만 나타내기 -> 0010 1110 & 0000 1111  = 00001110
-OR 연산자로 INSERT : 0000 1110 | 1011 000 = 1011 1110

시프트 연산 예
-시프트연산 : _100( =4) 총 4개의 비트 쓰는 것을 레프트 시프트 하면 1000(8) 이 된다. 이것은 곱하기 2의 결과랑 같다. 한칸씩만 이동해도!
반대로 라이트시프트하면 나누기 2 연산과 결과가 같다


마이크로 명령어 집합과 구성
컴퓨터가 step by step으로 처리되는 걸로는 딥러닝 등등을 처리하기 힘들다. 그래서 양자컴퓨터도 나오고 한다.
명령어도 다른형태의 변화들이 나타난다.

명령어(instruction) 집합
-순차적 실행 명령어 : 전체 실행 명령어의 70~80% 차지 . 순차 실행 되는 것!
-분기 명령어 :  분기 실행(branch execution). if문 써서 분기 처리 . P :R1<-R2
-부 함수 호출 명령어 : main함수에서 sub 함수로 호출하는 것
-복귀 명령어 : sub 함수에서 main 함수로 복귀하는것.

명령어 구문 형식

명령코드 : CPU가 실행할 수 있도록 디자인 된 연산. ALU에서 해석됨
오퍼랜드 : 연산에 사용되는 자료 값, 자료가 저장 된 주소에 관한 정보
주소지정모드(addressing mode ) : 오퍼랜드값이 뭔지 지정하는것!?
    ㄴDirect 모드 : 오퍼랜드 주소값으로  찾아간 결과 값으로 사용
    ㄴIndirect모드 : 오퍼랜드 주소값의 결과값이 또 다른 것의 주소 인 경우

명령어 집합의 설계
프로그램(S/W)의 관점
    자연어에 가까운 명령 코드 : 프로그램용이/ 전체 프로그램 길이 감소 / 번역기의 설계용이
    기계 중심의 명령 코드 : 프로그래밍 규칙이 많아짐 / 프로그램의 길이 증가 / 번역기의 설계가 복잡해진다.
CPU구조 설계 측면(H/W)
    자연어에 가까운 명령코드 : 사용언어에 따른 구조적 차이로 인한 오동작및 처리 어려움 / 명령어 길이 증가 / 제어장치(ALU,레지스터) 제어 매우 복잡
    기계 중심의 명령 코드 : 업체별 국가별 프로그래밍의 표준화 가능 / 명령어 종류 및 길이 간편화 / 제어장치의 제어가 상대적으로 용이

현업에서 활용되는 명령어군의 활용비율
Load, store, move  -자료 전송 명령어가 38%
Compare, add, and, sub -산술/논리 연산 명령어가 35%
Condition branch, call, return - 실행제어 명령어가 22%
-> 이상의 명령어가 전체 실행 명령어의 약 90% 이상임을 확인

주소 지정 모드 (addressing mode)
명령어의 구조상 자료가 저장되어 있는 장소를 지정하는 방법이 필요함. 이유는 최대한 하드웨어와 소프트웨어의 독립성을 유지하여 프로그램의 유연성(pointer, indexing등) 을 가능하게 하여 명령어의 수와 길이를 줄이기위한 세계적 표준화 기법

1.묵시적 모드 ( operand가 명령어에 포함되어 있지 않은 특수모드)
    NOP : NO Operation , 오퍼랜드가 필요없는 명령어. 이동명령어 같은것. 이걸 옮겨! 이런거
    INC : 묵시적 오퍼랜드인 누산기(AC)의 연산 명령어. 누산기에 자료 집어넣어! 다음내용 표시해! 이런거
    ADD : 스택구조(LIFO)의 명령어( 스택에 오퍼랜드가 저장) .pop,push로 넣고 빼고 할 수 있으니 특별히 오퍼랜드 필요x
2.직접값 모드 ( operand 자체가 명령어에 포함되어 있는 모드)
    ex) MOV R1, #100;  : 십진수 100이 두번째 오퍼랜드로 직접 명령문에 포함됨
3. 레지스터 모드 (Register mode : 오퍼랜드가 레지스터에 저장된 모드)
    ex) ADD R1, R2;      : 레지스터 R1,R2에 보유하고 있는 값이 오퍼랜드
4. 메모리 직접 주소 모드( Direct mode : 오퍼랜드가 저장된 메모리 주소를 나타내는 모드)
    ex) MOV R1,100;     : R1에 100번지의 내용을 이동하라는 내용.(기종에 따라 반대의경우도 가능) 100번지의 내용이 두번째 오퍼랜드!
5. 메모리 간접 주소 모드 ( Memory indirect :메모리를 이용하여 간접적으로 주소를 지정하는 모드 )
    ex) MOV R1, @100; R1<-M[100] or M[100] <-R1                    100번지의 값이 다시 다른곳의 주소라서 그 값을 찾기
